# SpecSwarm v3.1.0 Implementation Plan

**Release Type**: Minor Version (Feature Addition)
**Target Date**: TBD (2-3 weeks after v3.0.0)
**Status**: Planning Phase
**Complexity**: MEDIUM-HIGH

---

## Executive Summary

SpecSwarm v3.1.0 adds 4 critical commands that fill identified gaps in the command ecosystem:
1. **`init`** - Streamlined project initialization
2. **`rollback`** - Safe feature rollback/recovery
3. **`security-audit`** - Security vulnerability scanning
4. **`release`** - Automated release preparation

**Goal**: Address the 4 highest-priority gaps identified in v3.0.0 command analysis.

**Impact**: Completes the command ecosystem, making SpecSwarm a comprehensive development toolkit.

---

## Feature 1: `/specswarm:init` - Project Initialization

### Purpose
Single command to set up all SpecSwarm foundation files for a new project.

### Current Problem
Users must manually:
1. Run `/specswarm:constitution`
2. Manually create `/memory/tech-stack.md`
3. Manually create `/memory/quality-standards.md`

**Result**: 3 steps, 2 requiring manual file creation - poor UX for new users.

### Proposed Solution
Interactive command that creates all 3 foundation files.

### User Flow

```bash
/specswarm:init

# Interactive questions:
# 1. Project name? [Auto-detect from package.json or ask]
# 2. Tech stack detection:
#    - Auto-detect from package.json dependencies
#    - Confirm with user
#    - Allow additions/removals
# 3. Quality thresholds:
#    - Min quality score? (default 80)
#    - Min test coverage? (default 80)
#    - Max bundle size? (optional)
# 4. Coding principles:
#    - Use defaults? [Yes/No]
#    - If No: Provide 3-5 principles
# 5. Confirmation:
#    - Show summary of what will be created
#    - Confirm to proceed

# Output:
# âœ… Created /memory/constitution.md
# âœ… Created /memory/tech-stack.md
# âœ… Created /memory/quality-standards.md
#
# Next steps:
#   1. Review files in /memory/
#   2. Run: /specswarm:build "your first feature"
#   3. Run: /specswarm:ship
```

### Technical Design

#### 1. Detection Phase
```bash
# Auto-detect from package.json
- React version (if present)
- TypeScript (if @types packages)
- Testing framework (vitest, jest, playwright)
- Styling (tailwindcss, styled-components)
- State management (zustand, redux)
```

#### 2. Interactive Phase (AskUserQuestion)
```javascript
Question 1: "What is your project name?"
  - Auto-detect from package.json "name"
  - Allow override

Question 2: "We detected these technologies. Is this correct?"
  - Show detected tech stack
  - Options: "Yes, looks good" | "Let me modify" | "Start from scratch"

Question 3 (if modify): "What technologies do you want to add/remove?"
  - Provide common options
  - Allow custom input

Question 4: "What quality thresholds do you want?"
  - Min quality score: 80 (default)
  - Min test coverage: 80 (default)
  - Max bundle size: optional

Question 5: "Do you want to use default coding principles?"
  - Options: "Yes, use defaults" | "Let me provide custom principles"
  - Defaults: DRY, SOLID, type safety, test coverage, documentation
```

#### 3. Generation Phase
```bash
# Use existing constitution logic
SlashCommand /specswarm:constitution with auto-answers

# Create tech-stack.md
Write file with detected + confirmed technologies

# Create quality-standards.md
Write file with confirmed thresholds
```

#### 4. Files Created

**`/memory/constitution.md`**:
- Project name
- 3-5 coding principles
- Enforcement rules
- Template updates

**`/memory/tech-stack.md`** (NEW TEMPLATE):
```markdown
## Project: [PROJECT_NAME]

### Core Technologies
- [FRAMEWORK] [VERSION] ([NOTES])
- [LANGUAGE] [VERSION]
- [BUILD_TOOL] [VERSION]

### Libraries
**State Management**:
- [LIBRARY] [VERSION]

**Styling**:
- [LIBRARY] [VERSION]

**Testing**:
- [TEST_FRAMEWORK] [VERSION] (unit tests)
- [E2E_FRAMEWORK] [VERSION] (e2e tests)

### Approved Libraries
- [LIBRARY_1] - [PURPOSE]
- [LIBRARY_2] - [PURPOSE]

### Prohibited
- âŒ [LIBRARY] - [REASON]
- âŒ [PATTERN] - [REASON]

### Notes
- Updated: [DATE]
- Auto-detected: [YES/NO]
```

**`/memory/quality-standards.md`** (NEW TEMPLATE):
```yaml
# Quality Gates
min_test_coverage: 80
min_quality_score: 80

# Performance Budgets
enforce_budgets: true
max_bundle_size: 500      # KB per bundle
max_initial_load: 1000    # KB initial load

# Code Quality
complexity_threshold: 10   # Cyclomatic complexity
max_file_lines: 300       # Lines per file
max_function_lines: 50    # Lines per function

# Testing
require_tests: true
test_types:
  - unit
  - integration
  - e2e

# CI/CD
block_merge_on_failure: true
require_code_review: true

# Notes
updated: [DATE]
auto_generated: [YES/NO]
```

### Implementation Complexity
- **Complexity**: MEDIUM
- **LOC Estimate**: 350-450 lines
- **Dependencies**:
  - Existing constitution command
  - AskUserQuestion tool (multi-question)
  - Package.json parser
- **Testing**: Interactive flow testing

### Edge Cases
1. **No package.json**: Ask user to specify everything manually
2. **Files already exist**: Offer to update vs recreate vs skip
3. **Invalid framework versions**: Validate against known versions
4. **Empty responses**: Provide sensible defaults

---

## Feature 2: `/specswarm:rollback` - Feature Rollback

### Purpose
Safely rollback a failed or unwanted feature with artifact cleanup.

### Current Problem
Users must manually:
1. `git revert` or `git reset`
2. Delete feature artifacts (spec.md, plan.md, tasks.md)
3. Clean up orphaned branches
4. Risk leaving inconsistent state

**Result**: Error-prone, manual, risky.

### Proposed Solution
Automated rollback with safety checks and artifact cleanup.

### User Flow

```bash
/specswarm:rollback

# Auto-detect current feature:
# "You are on branch: feature/015-user-authentication"
# "Feature artifacts found:"
#   - spec.md (125 lines)
#   - plan.md (87 lines)
#   - tasks.md (43 tasks, 12 completed)
#
# âš ï¸ WARNING: This will:
#   1. Revert all code changes since branch creation
#   2. Delete feature artifacts
#   3. Optionally delete branch
#
# Choose rollback strategy:
#   [1] Soft rollback (keep history, create revert commits)
#   [2] Hard rollback (reset to parent branch state)
#   [3] Cancel
#
# User selects: [1]
#
# Additional options:
#   - Delete branch after rollback? [Yes/No]
#   - Keep artifacts for reference? [Yes/No]
#
# Confirmation:
#   "Type 'rollback' to confirm:"
#
# Executing rollback...
# âœ… Created revert commits
# âœ… Deleted spec.md, plan.md, tasks.md
# âœ… Branch feature/015-user-authentication deleted
# âœ… Switched to parent branch: develop
```

### Technical Design

#### 1. Detection Phase
```bash
# Current branch
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)

# Parent branch (from feature creation or config)
PARENT_BRANCH=$(git config branch.$CURRENT_BRANCH.parent || echo "main")

# Commits since branch creation
DIVERGE_POINT=$(git merge-base $CURRENT_BRANCH $PARENT_BRANCH)
COMMITS_TO_ROLLBACK=$(git log --oneline $DIVERGE_POINT..$CURRENT_BRANCH)

# Feature artifacts
FEATURE_DIR=$(pwd)/.feature
if [ -d "$FEATURE_DIR" ]; then
  # Count artifacts
  SPEC_EXISTS=$( [ -f "$FEATURE_DIR/spec.md" ] && echo "yes" || echo "no" )
  PLAN_EXISTS=$( [ -f "$FEATURE_DIR/plan.md" ] && echo "yes" || echo "no" )
  TASKS_EXISTS=$( [ -f "$FEATURE_DIR/tasks.md" ] && echo "yes" || echo "no" )
fi
```

#### 2. Safety Checks
```bash
# Check if on main/master (prevent rollback)
if [ "$CURRENT_BRANCH" = "main" ] || [ "$CURRENT_BRANCH" = "master" ]; then
  echo "âŒ Cannot rollback main/master branch"
  exit 1
fi

# Check if already merged
MERGED=$(git branch --merged $PARENT_BRANCH | grep $CURRENT_BRANCH)
if [ -n "$MERGED" ]; then
  echo "âš ï¸ WARNING: Branch already merged to $PARENT_BRANCH"
  echo "Rollback will create revert commits on $PARENT_BRANCH"
  # Require special confirmation
fi

# Check for uncommitted changes
DIRTY=$(git status --porcelain)
if [ -n "$DIRTY" ]; then
  echo "âŒ Uncommitted changes detected. Commit or stash first."
  exit 1
fi
```

#### 3. Interactive Phase (AskUserQuestion)
```javascript
Question 1: "Choose rollback strategy"
  header: "Strategy"
  options:
    - label: "Soft rollback (revert commits)"
      description: "Creates revert commits, preserves history"
    - label: "Hard rollback (reset to parent)"
      description: "Deletes all commits, rewrites history (DANGEROUS)"
    - label: "Cancel"
      description: "Abort rollback"

Question 2: "Delete branch after rollback?"
  header: "Cleanup"
  options:
    - label: "Yes, delete branch"
      description: "Remove feature branch completely"
    - label: "No, keep branch"
      description: "Keep branch for reference"

Question 3: "Keep artifacts for reference?"
  header: "Artifacts"
  options:
    - label: "Delete artifacts"
      description: "Remove spec.md, plan.md, tasks.md"
    - label: "Keep artifacts"
      description: "Move to .feature.backup/"

Question 4: "Type 'rollback' to confirm"
  header: "Confirmation"
  text_input: true
```

#### 4. Execution Phase
```bash
# Soft rollback
if [ "$STRATEGY" = "soft" ]; then
  # Create revert commits for each commit since divergence
  git revert $DIVERGE_POINT..$CURRENT_BRANCH --no-edit
fi

# Hard rollback
if [ "$STRATEGY" = "hard" ]; then
  # Switch to parent branch
  git checkout $PARENT_BRANCH
  # Delete feature branch (will prompt for force if unmerged)
  git branch -D $CURRENT_BRANCH
fi

# Artifact cleanup
if [ "$DELETE_ARTIFACTS" = "yes" ]; then
  rm -rf .feature/
else
  # Backup
  mkdir -p .feature.backup
  mv .feature/* .feature.backup/
  rm -rf .feature/
fi

# Branch cleanup
if [ "$DELETE_BRANCH" = "yes" ]; then
  git branch -D $CURRENT_BRANCH
fi
```

### Implementation Complexity
- **Complexity**: MEDIUM-HIGH
- **LOC Estimate**: 400-500 lines
- **Dependencies**:
  - Git operations
  - AskUserQuestion tool (multi-question with text input)
  - Feature detection logic
- **Testing**: Requires git scenario testing

### Edge Cases
1. **Already merged**: Special handling, warn about revert commits on parent
2. **No parent branch**: Ask user to specify
3. **Uncommitted changes**: Require commit/stash first
4. **Remote tracking**: Warn if branch is pushed to remote
5. **Multiple features**: If artifacts overlap, careful cleanup

### Safety Features
- âœ… Confirmation required (type 'rollback')
- âœ… Cannot rollback main/master
- âœ… Dry-run option
- âœ… Backup artifacts option
- âœ… Prevent rollback with uncommitted changes

---

## Feature 3: `/specswarm:security-audit` - Security Scanning

### Purpose
Automated security vulnerability scanning and OWASP Top 10 analysis.

### Current Problem
Users must:
1. Run `npm audit` manually
2. Check for hardcoded secrets manually
3. Review code for OWASP Top 10 manually
4. Use external security tools

**Result**: Security often overlooked, manual process, inconsistent.

### Proposed Solution
Automated security audit with actionable recommendations.

### User Flow

```bash
/specswarm:security-audit

# Scanning...
# [1/5] Checking dependencies (npm audit)...
# [2/5] Scanning for hardcoded secrets...
# [3/5] Analyzing code patterns (OWASP Top 10)...
# [4/5] Checking security configurations...
# [5/5] Generating report...

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                   SECURITY AUDIT REPORT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# Overall Risk Level: MEDIUM
# Critical Issues: 0
# High Issues: 2
# Medium Issues: 5
# Low Issues: 3
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CRITICAL ISSUES (0)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# (None)
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HIGH ISSUES (2)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# [H1] SQL Injection Vulnerability
#   Location: src/db/queries.ts:45
#   Pattern: Direct string concatenation in SQL query
#   Risk: Attacker can execute arbitrary SQL
#   Fix: Use parameterized queries
#   Example:
#     âŒ query(`SELECT * FROM users WHERE id = ${userId}`)
#     âœ… query('SELECT * FROM users WHERE id = ?', [userId])
#   Reference: https://owasp.org/www-project-top-ten/2017/A1_2017-Injection
#
# [H2] Dependency Vulnerability: express@4.17.1
#   CVE: CVE-2022-24999
#   Severity: HIGH
#   Vulnerable versions: <4.17.3
#   Fix: npm install express@4.17.3
#   Reference: https://nvd.nist.gov/vuln/detail/CVE-2022-24999
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MEDIUM ISSUES (5)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# [M1] Hardcoded Secret Detected
#   Location: src/config/api.ts:12
#   Pattern: Hardcoded API key
#   Risk: Secret exposed in source code
#   Fix: Use environment variables
#   Example:
#     âŒ const API_KEY = "sk_live_abc123..."
#     âœ… const API_KEY = process.env.API_KEY
#
# [M2] Missing CSRF Protection
#   Location: src/routes/api.ts
#   Pattern: POST endpoint without CSRF token
#   Risk: Cross-Site Request Forgery attacks
#   Fix: Implement CSRF tokens (csurf middleware)
#   Reference: https://owasp.org/www-project-top-ten/2017/A8_2017-Cross-Site_Request_Forgery
#
# [... additional issues ...]
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SUMMARY & RECOMMENDATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# 1. Fix 2 HIGH severity issues immediately
# 2. Update vulnerable dependencies: express, lodash
# 3. Move hardcoded secrets to environment variables
# 4. Implement CSRF protection for state-changing endpoints
# 5. Add input validation for user-supplied data
#
# Report saved to: security-audit-2025-11-08.md
```

### Technical Design

#### 1. Dependency Scanning
```bash
# Run npm audit and parse JSON output
npm audit --json > /tmp/audit.json

# Parse vulnerabilities
jq '.vulnerabilities' /tmp/audit.json

# Categorize by severity:
# - critical â†’ CRITICAL
# - high â†’ HIGH
# - moderate â†’ MEDIUM
# - low â†’ LOW
```

#### 2. Secret Detection
```bash
# Patterns to detect:
# - API keys (sk_live_, pk_test_, etc.)
# - AWS credentials (AKIA...)
# - Private keys (-----BEGIN PRIVATE KEY-----)
# - Passwords (password=, pwd=, etc.)
# - Tokens (token=, auth_token=, etc.)

# Use grep with patterns
grep -rn "sk_live_\|pk_test_\|AKIA\|-----BEGIN PRIVATE KEY-----\|password=\|pwd=\|token=" src/

# Exclude:
# - .env.example files
# - Test files with dummy secrets
# - Comments explaining secret patterns
```

#### 3. OWASP Top 10 Code Analysis
```bash
# A1: Injection
# - SQL injection: Look for string concatenation in queries
# - Command injection: Look for exec/spawn with user input
# - NoSQL injection: Look for unvalidated MongoDB queries

# A2: Broken Authentication
# - Weak password requirements
# - No rate limiting on login
# - Session tokens in URL

# A3: Sensitive Data Exposure
# - Logging sensitive data
# - Storing passwords in plain text
# - Missing encryption

# A4: XML External Entities (XXE)
# - XML parsing without disabling external entities

# A5: Broken Access Control
# - Missing authorization checks
# - Direct object references without validation

# A6: Security Misconfiguration
# - Default credentials
# - Verbose error messages
# - Missing security headers

# A7: Cross-Site Scripting (XSS)
# - dangerouslySetInnerHTML in React
# - Unescaped user input in templates

# A8: Insecure Deserialization
# - eval() usage
# - Unvalidated JSON.parse()

# A9: Using Components with Known Vulnerabilities
# - Covered by npm audit

# A10: Insufficient Logging & Monitoring
# - No logging of authentication failures
# - No audit trail
```

#### 4. Security Configuration Checks
```bash
# Check for:
# - HTTPS enforcement
# - Security headers (CSP, X-Frame-Options, etc.)
# - CORS configuration
# - Rate limiting
# - Input validation
# - Output encoding
```

#### 5. Report Generation
```markdown
# Security Audit Report

Date: [DATE]
Project: [PROJECT_NAME]
Auditor: SpecSwarm Security Audit v3.1.0

## Executive Summary
- Overall Risk: [CRITICAL/HIGH/MEDIUM/LOW]
- Critical Issues: [COUNT]
- High Issues: [COUNT]
- Medium Issues: [COUNT]
- Low Issues: [COUNT]

## Findings

### Critical Issues
[Details for each critical issue]

### High Issues
[Details for each high issue]

### Medium Issues
[Details for each medium issue]

### Low Issues
[Details for each low issue]

## Recommendations
[Prioritized list of fixes]

## Next Steps
1. Fix critical issues immediately
2. Address high issues within 1 week
3. Plan medium/low issues for next sprint
4. Re-run audit after fixes
```

### Implementation Complexity
- **Complexity**: HIGH
- **LOC Estimate**: 600-800 lines
- **Dependencies**:
  - npm audit (built-in)
  - grep/regex for pattern matching
  - Code AST parsing for advanced analysis
- **Testing**: Requires test projects with known vulnerabilities

### Edge Cases
1. **No package.json**: Skip dependency scanning, focus on code
2. **Monorepo**: Scan all workspaces
3. **False positives**: Allow exclusions via config
4. **Non-JS projects**: Adapt for Python, etc.

### Integration Points
- Could integrate with `analyze-quality` (add security score)
- Could be run before `ship` (security gate)
- Could generate issues for `bugfix` workflow

---

## Feature 4: `/specswarm:release` - Release Preparation

### Purpose
Automate version bumping, changelog generation, and release tagging.

### Current Problem
Users must manually:
1. Update version in package.json
2. Update CHANGELOG.md
3. Create git tag
4. Push to GitHub
5. Create GitHub release

**Result**: Error-prone, tedious, inconsistent changelogs.

### Proposed Solution
Automated release preparation with semver support.

### User Flow

```bash
/specswarm:release

# Auto-detect current version: 3.0.0
#
# What type of release?
#   [1] Major (4.0.0) - Breaking changes
#   [2] Minor (3.1.0) - New features
#   [3] Patch (3.0.1) - Bug fixes
#   [4] Custom version
#
# User selects: [2] Minor
#
# New version: 3.1.0
#
# Generate changelog from commits? [Yes/No]
# User selects: Yes
#
# Analyzing commits since v3.0.0...
# Found:
#   - 4 new features
#   - 8 bug fixes
#   - 3 documentation updates
#
# Preview CHANGELOG entry:
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ## [3.1.0] - 2025-11-XX
#
# ### Added
# - New /specswarm:init command for project setup
# - New /specswarm:rollback command for safe rollbacks
# - New /specswarm:security-audit for vulnerability scanning
# - New /specswarm:release for release automation
#
# ### Fixed
# - Fixed bug in build command (#123)
# - Improved error handling in ship command
# - [... other fixes ...]
#
# ### Documentation
# - Updated README with v3.1 features
# - Added security audit guide
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#
# Edit changelog? [Yes/No]
# User selects: No
#
# Create git tag? [Yes/No]
# User selects: Yes
#
# Push to GitHub? [Yes/No]
# User selects: Yes
#
# Create GitHub release? [Yes/No]
# User selects: Yes
#
# Executing release...
# âœ… Updated package.json (3.0.0 â†’ 3.1.0)
# âœ… Updated CHANGELOG.md
# âœ… Created git commit "release: v3.1.0"
# âœ… Created git tag v3.1.0
# âœ… Pushed to origin/main
# âœ… Pushed tag v3.1.0
# âœ… Created GitHub release: https://github.com/user/repo/releases/tag/v3.1.0
#
# Release complete! ğŸ‰
```

### Technical Design

#### 1. Version Detection
```bash
# Read current version from package.json
CURRENT_VERSION=$(jq -r '.version' package.json)

# Parse semver
MAJOR=$(echo $CURRENT_VERSION | cut -d. -f1)
MINOR=$(echo $CURRENT_VERSION | cut -d. -f2)
PATCH=$(echo $CURRENT_VERSION | cut -d. -f3)
```

#### 2. Semver Bump Logic
```bash
# Major: X.0.0 (breaking changes)
NEW_MAJOR=$((MAJOR + 1))
NEW_VERSION_MAJOR="$NEW_MAJOR.0.0"

# Minor: X.Y.0 (new features)
NEW_MINOR=$((MINOR + 1))
NEW_VERSION_MINOR="$MAJOR.$NEW_MINOR.0"

# Patch: X.Y.Z (bug fixes)
NEW_PATCH=$((PATCH + 1))
NEW_VERSION_PATCH="$MAJOR.$MINOR.$NEW_PATCH"
```

#### 3. Changelog Generation
```bash
# Get commits since last tag
LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
if [ -z "$LAST_TAG" ]; then
  # No tags, use all commits
  COMMITS=$(git log --oneline --no-merges)
else
  # Commits since last tag
  COMMITS=$(git log --oneline --no-merges $LAST_TAG..HEAD)
fi

# Categorize commits by conventional commit format:
# feat: â†’ Added
# fix: â†’ Fixed
# docs: â†’ Documentation
# refactor: â†’ Changed
# perf: â†’ Performance
# test: â†’ Testing
# chore: â†’ Maintenance

# Parse commit messages
while IFS= read -r commit; do
  HASH=$(echo "$commit" | awk '{print $1}')
  MSG=$(echo "$commit" | cut -d' ' -f2-)

  if [[ "$MSG" =~ ^feat: ]]; then
    ADDED+=("- ${MSG#feat: } ($HASH)")
  elif [[ "$MSG" =~ ^fix: ]]; then
    FIXED+=("- ${MSG#fix: } ($HASH)")
  elif [[ "$MSG" =~ ^docs: ]]; then
    DOCS+=("- ${MSG#docs: } ($HASH)")
  fi
done <<< "$COMMITS"
```

#### 4. CHANGELOG.md Update
```markdown
# Insert at top of CHANGELOG.md (after header)

## [NEW_VERSION] - $(date +%Y-%m-%d)

### Added
${ADDED[@]}

### Fixed
${FIXED[@]}

### Documentation
${DOCS[@]}

---

[... existing changelog entries ...]
```

#### 5. Package.json Update
```bash
# Use jq to update version
jq ".version = \"$NEW_VERSION\"" package.json > package.json.tmp
mv package.json.tmp package.json
```

#### 6. Git Operations
```bash
# Commit changes
git add package.json CHANGELOG.md
git commit -m "release: v$NEW_VERSION"

# Create annotated tag
git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"

# Push to remote
git push origin main
git push origin "v$NEW_VERSION"
```

#### 7. GitHub Release
```bash
# Use gh CLI to create release
gh release create "v$NEW_VERSION" \
  --title "v$NEW_VERSION" \
  --notes-file <(extract_changelog_entry)
```

### Interactive Phase (AskUserQuestion)
```javascript
Question 1: "What type of release?"
  header: "Version"
  options:
    - label: "Major (breaking changes)"
      description: "X.0.0 - Incompatible API changes"
    - label: "Minor (new features)"
      description: "X.Y.0 - Backward-compatible features"
    - label: "Patch (bug fixes)"
      description: "X.Y.Z - Backward-compatible fixes"
    - label: "Custom version"
      description: "Specify custom version number"

Question 2: "Generate changelog from commits?"
  header: "Changelog"
  options:
    - label: "Yes, auto-generate"
      description: "Parse commits using conventional commit format"
    - label: "No, I'll edit manually"
      description: "Skip changelog generation"

Question 3: "Create git tag?"
  header: "Tagging"
  options:
    - label: "Yes"
    - label: "No"

Question 4: "Push to GitHub?"
  header: "Push"
  options:
    - label: "Yes, push main and tag"
    - label: "No, keep local only"

Question 5: "Create GitHub release?"
  header: "GitHub"
  options:
    - label: "Yes, create release"
    - label: "No, just tag"
```

### Implementation Complexity
- **Complexity**: MEDIUM
- **LOC Estimate**: 500-600 lines
- **Dependencies**:
  - jq (JSON parsing)
  - git operations
  - gh CLI (GitHub releases)
  - Conventional commit parser
- **Testing**: Requires test repository

### Edge Cases
1. **No package.json**: Support other version files (pyproject.toml, Cargo.toml)
2. **No CHANGELOG.md**: Create new one
3. **No conventional commits**: Use generic categories
4. **Already released version**: Warn and prevent duplicate
5. **Dirty working tree**: Require clean state

### Integration Points
- Could be part of `complete` workflow
- Could integrate with `ship` (release after merge)
- Could trigger CI/CD pipelines

---

## Implementation Timeline

### Week 1: Foundation & init
**Focus**: Project initialization command

**Tasks**:
1. Design tech-stack.md template
2. Design quality-standards.md template
3. Implement package.json detection
4. Implement interactive flow
5. Integrate with existing constitution command
6. Testing (manual + automated)
7. Documentation

**Deliverable**: `/specswarm:init` command (350-450 LOC)

### Week 2: rollback & security-audit
**Focus**: Safety and security features

**Tasks**:
1. **Rollback** (Days 1-3):
   - Implement feature detection
   - Implement safety checks
   - Implement soft/hard rollback strategies
   - Artifact cleanup logic
   - Testing (complex git scenarios)

2. **Security Audit** (Days 4-7):
   - Implement dependency scanning
   - Implement secret detection
   - Implement OWASP patterns
   - Report generation
   - Testing (vulnerability database)

**Deliverables**:
- `/specswarm:rollback` (400-500 LOC)
- `/specswarm:security-audit` (600-800 LOC)

### Week 3: release & Integration
**Focus**: Release automation and integration testing

**Tasks**:
1. **Release** (Days 1-3):
   - Implement version detection/bumping
   - Implement changelog generation
   - Implement git operations
   - GitHub release integration
   - Testing

2. **Integration** (Days 4-5):
   - Cross-feature testing
   - Update existing commands for integration
   - Performance testing

3. **Documentation** (Days 6-7):
   - Update README.md
   - Create v3.1.0 migration guide
   - Update CHANGELOG.md
   - Update command reference

**Deliverable**: `/specswarm:release` (500-600 LOC)

### Week 4: Testing & Release
**Focus**: Quality assurance and release

**Tasks**:
1. Comprehensive integration testing
2. User acceptance testing
3. Documentation review
4. Version updates (3.1.0-alpha.1 â†’ 3.1.0)
5. Create release PR
6. Merge to main
7. Tag v3.1.0
8. GitHub release

**Deliverable**: SpecSwarm v3.1.0 released

---

## Success Criteria

### Functional Requirements
- [ ] `/specswarm:init` creates all 3 foundation files correctly
- [ ] `/specswarm:rollback` safely reverts features without data loss
- [ ] `/specswarm:security-audit` detects all OWASP Top 10 patterns
- [ ] `/specswarm:release` bumps version and generates changelog

### Quality Requirements
- [ ] 100% integration test pass rate
- [ ] All 4 commands documented
- [ ] Migration guide created
- [ ] Zero breaking changes

### User Experience
- [ ] Init reduces setup from 3 steps to 1
- [ ] Rollback provides clear confirmation prompts
- [ ] Security audit gives actionable recommendations
- [ ] Release automates 5 manual steps

### Performance
- [ ] Init completes in <30 seconds
- [ ] Rollback completes in <10 seconds
- [ ] Security audit completes in <60 seconds
- [ ] Release completes in <30 seconds

---

## Risk Assessment

### High Risks

**1. Rollback Data Loss**
- **Risk**: Hard rollback could lose important work
- **Mitigation**:
  - Confirmation prompts
  - Backup option
  - Dry-run mode
  - Clear warnings

**2. Security Audit False Positives**
- **Risk**: Too many false positives reduce trust
- **Mitigation**:
  - Configurable exclusions
  - Context-aware pattern matching
  - Allow user to mark false positives

**3. Release Version Conflicts**
- **Risk**: Multiple releases happening simultaneously
- **Mitigation**:
  - Check for existing tags
  - Require clean working tree
  - Validate version doesn't exist

### Medium Risks

**4. Init Overwrites Existing Files**
- **Risk**: Destroys existing configuration
- **Mitigation**:
  - Check for existing files first
  - Offer update vs recreate
  - Backup option

**5. Security Audit Performance**
- **Risk**: Large codebases take too long
- **Mitigation**:
  - Parallel scanning
  - Incremental scanning
  - Configurable scan depth

### Low Risks

**6. Changelog Format Inconsistency**
- **Risk**: Generated changelog doesn't match conventions
- **Mitigation**:
  - Follow Keep a Changelog format
  - Allow manual editing
  - Template customization

---

## Code Estimate

| Feature | LOC Estimate | Complexity |
|---------|--------------|------------|
| `/specswarm:init` | 350-450 | MEDIUM |
| `/specswarm:rollback` | 400-500 | MEDIUM-HIGH |
| `/specswarm:security-audit` | 600-800 | HIGH |
| `/specswarm:release` | 500-600 | MEDIUM |
| **Total** | **1,850-2,350** | **HIGH** |

Additional:
- Templates: 200-300 LOC
- Tests: 500-700 LOC
- Documentation: 800-1,000 LOC

**Grand Total**: 3,350-4,350 LOC

---

## Testing Strategy

### Unit Tests
- [ ] Version parsing (release)
- [ ] Semver bumping (release)
- [ ] Pattern matching (security-audit)
- [ ] Commit parsing (release)

### Integration Tests
- [ ] End-to-end init flow
- [ ] Soft rollback scenario
- [ ] Hard rollback scenario
- [ ] Security scan on test project
- [ ] Release with changelog generation

### Manual Testing
- [ ] Interactive flows (all commands)
- [ ] Edge cases (each command)
- [ ] Error handling
- [ ] User experience

### Regression Testing
- [ ] Ensure v3.0.0 commands still work
- [ ] Backward compatibility maintained
- [ ] No breaking changes

---

## Documentation Plan

### New Documentation
1. **`docs/v3.1.0-FEATURES.md`** - Feature descriptions
2. **`docs/SECURITY-AUDIT-GUIDE.md`** - Security audit interpretation
3. **`docs/ROLLBACK-GUIDE.md`** - When and how to rollback

### Updated Documentation
1. **`README.md`** - Add 4 new commands
2. **`CHANGELOG.md`** - v3.1.0 entry
3. **`docs/WORKFLOW.md`** - Include init in setup
4. **`docs/CHEATSHEET.md`** - Add new commands
5. **`docs/COMMAND-ANALYSIS-v3.0.0.md`** - Update with v3.1.0

---

## Open Questions

1. **Init**: Should we support non-JS projects (Python, Rust, etc.)?
2. **Rollback**: Should we support rollback of merged features (revert on main)?
3. **Security**: Should we integrate with external security APIs (Snyk, etc.)?
4. **Release**: Should we support pre-release versions (alpha, beta, rc)?
5. **All**: Should these commands work in monorepos?

---

## Next Steps

1. **Review this plan** - Validate approach and priorities
2. **Create feature branch** - `feature/v3.1.0-four-commands`
3. **Week 1 implementation** - Start with `/specswarm:init`
4. **Iterative development** - One command per week
5. **Integration testing** - Week 3-4
6. **Release v3.1.0** - Week 4

---

**Status**: Ready for approval
**Estimated Effort**: 3-4 weeks (1 developer)
**Target Release**: 2-3 weeks after v3.0.0
**Impact**: HIGH (completes command ecosystem)
